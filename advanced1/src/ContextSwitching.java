public class ContextSwitching {
    /*
    컨텍스트 스위칭
        멀티태스킹이 반드시 효율적인 것 만은 아니다.

        사람의 멀티태스킹
            비유를 하자면 내가 프로그램 A를 개발하고 있는데 갑자기 기획자가 프로그램 B를 수정해달라고 한다.
            프로그램 A의 개발을 멈추고 프로그램 B를 수정한다고 가정해보자.
            여기서 프로그램 B의 수정을 잘 마치고 다시 프로그램 A를 개발하기 위해 돌아간다.
            이때 먼저 프로그램 A의 어디를 개발하고 있었는지 해당 코드의 위치를 찾아야 한다.
            그리고 개발할 때 변수들을 많이 선언하는데 변수들에 어떤 값들이 들어가는지 머리속에 다시 불러와야 한다.
            만약 프로그램 A의 개발이 다 끝나고 나서 프로그램 B를 수정한다면 전체 시간으로 보면 더 효율적으로 개발할 수 있을 것이다.

        컴퓨터의 멀티태스킹
            운영체제의 멀티태스킹을 생각해보자. CPU 코어는 하나만 있다고 가정하자.
            스레드 A, 스레드 B가 있다.
            운영체제는 먼저 스레드 A를 실행한다.
            멀티태스킹을 해야 하기 때문에 스레드 A를 계속 실행할 수 없다.
            스레드 A를 잠시 멈추고 스레드 B를 실행한다.
            이후에 스레드 A로 그냥 돌아갈 수 없다.
            CPU 에서 스레드를 실행하는데 스레드 A의 코드가 어디까지 수행되었는지 위치를 찾아야 한다.
            그리고 계산하던 변수들의 값을 CPU 에 다시 불러들여야 한다.
            따라서 스레드 A를 멈추는 시점에 CPU 에서 사용하던 이런 값들을 메모리에 저장해두어야 한다.
            그리고 이후에 스레드 A를 다시 실행할 때 이 값들을 CPU 에 다시 불러와야 한다.

        이런 과정을 컨텍스트 스위칭(context switching)이라 한다.
        컨텍스트는 현재 작업하는 문맥을 뜻한다. 현재 작업하는 문맥이 변하기 때문에 컨텍스트 스위칭이다.
        컨텍스트 스위칭 과정에서 이전에 실행 중인 값을 메모리에 잠깐 저장하고 이후에 다시 실행하는 시점에 저장한 값을 CPU 에 다시 불러와야 한다.
        결과적으로 컨텍스트 스위칭 과정에는 약간의 비용이 발생한다.

        멀티스레드는 대부분 효율적이지만 컨텍스트 스위칭 과정이 필요하므로 항상 효율적인 것은 아니다.
            예를 들어서 1 ~ 10000까지 더해야 한다고 가정해보자. 이 문제는 둘로 나눌 수 있다.
            스레드1: 1 ~ 5000까지 더함
            스레드2: 5001 ~ 10000까지 더함
            마지막에 스레드 1의 결과와 스레드 2의 결과를 더함

            CPU 코어가 2개
                CPU 코어가 2개 있다면 스레드1, 스레드2로 나누어 멀티스레드로 병렬 처리하는게 효율적이다.
                모든 CPU 를 사용하므로 연산을 2배 빠르게 처리할 수 있다.

            CPU 코어가 1개
                CPU 코어가 1개 있는데 스레드를 2개로 만들어서 연산하면 중간중간 컨텍스트 스위칭 비용이 발생한다.
                운영체제 스케줄링 방식에 따라서 다르겠지만 스레드1을 1 ~ 1000 정도까지 연산한 상태에서 잠시 멈추고 스레드2를 5001 ~ 6001까지 연산하는 식으로 반복할 수 있다.
                이때 CPU 는 스레드 1을 멈추고 다시 실행할 때 어디까지 연산했는지 알아야 하고 그 값을 CPU 에 다시 불러와야 한다.
                결과적으로 이렇게 반복할 때 마다 컨텍스트 스위칭 비용(시간)이든다.
                결과적으로 연산 시간 + 컨텍스트 스위칭 시간이 든다.
                이런 경우 단일 스레드로 1 ~ 10000까지 더하는 것이 컨텍스트 스위칭 비용 없이 연산 시간만 사용하기 때문에 더 효율적이다.

                예를 이렇게 들었지만 실제로 컨텍스트 스위칭에 걸리는 시간은 아주 짧다.
                하지만 스레드가 매우 많다면 이 비용이 커질 수 있다.
                물론 최신 CPU 는 초당 수 십억 단위를 계산하기 때문에 실제로는 계산에 더 큰 숫자를 사용해야 컨텍스트 스위칭이 발생한다.

    참고
        CPU 4개, 스레드 2개
            스레드의 숫자가 너무 적으면 모든 CPU 를 100% 다 활용할 수 없지만 스레드가 몇 개 없으므로 컨텍스트 스위칭 비용이 줄어든다.

        CPU 4개, 스레드 100개
            스레드의 숫자가 너무 많으면 CPU 를 100% 다 활용할 수 있지만 컨텍스트 스위칭 비용이 늘어난다.

        CPU 4개, 스레드 4개
            스레드의 숫자를 CPU 의 숫자에 맞춘다면 CPU 를 100% 활용할 수 있고 컨텍스트 스위칭 비용도 자주 발생하지 않기 때문에 최적의 상태가 된다.
            이상적으로는 CPU 코어 수 + 1개 정도로 스레드를 맞추면 특정 스레드가 잠시 대기할 때 남은 스레드를 활용할 수 있다.

        CPU 바운드 작업 vs I/O 바운드 작업
            각각의 스레드가 하는 작업은 크게 2가지로 구분할 수 있다.

            - CPU 바운드 작업 (CPU-bound tasks)
                CPU 의 연산 능력을 많이 요구하는 작업을 의미한다.
                이러한 작업은 주로 계산, 데이터 처리, 알고리즘 실행 등 CPU 의 처리 속도가 작업 완료 시간을 결정하는 경우다.
                예시: 복잡한 수학 연산, 데이터 분석, 비디오 인코딩, 과학적 시뮬레이션 등

            - I/O 바운드 작업 (I/O-bound tasks)
                디스크, 네트워크, 파일 시스템 등과 같은 입출력(I/O) 작업을 많이 요구하는 작업을 의미한다.
                이러한 작업은 I/O 작업이 완료될 때까지 대기 시간이 많이 발생하며 CPU 는 상대적으로 유휴(대기) 상태에 있는 경우가 많다.
                쉽게 이야기해서 스레드가 CPU 를 사용하지 않고 I/O 작업이 완료될 때 까지 대기한다.
                예시: 데이터베이스 쿼리 처리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 처리 등.

        웹 애플리케이션 서버
            분야마다 다르겠지만 실무에서는 CPU-바운드 작업 보다는 I/O-바운드 작업이 많다.
            예를 들어서 백엔드 개발자의 경우 주로 웹 애플리케이션 서버를 개발하는데 스레드가 1 ~ 10000까지 더하는 CPU 의 연산이 필요한 작업보다는
            대부분 사용자의 입력을 기다리거나, 데이터베이스를 호출하고 그 결과를 기다리는 등의 일이 많다.
            쉽게 이야기해서 스레드가 CPU 를 많이 사용하지 않는 I/O-바운드 작업이 많다는 뜻이다.

            일반적인 자바 웹 애플리케이션 서버의 경우 사용자의 요청 하나를 처리하는데 1개의 스레드가 필요하다.
            사용자 4명이 동시에 요청하면 4개의 스레드가 작동하는 것이다. 그래야 4명의 사용자의 요청을 동시에 처리할 수 있다.
            사용자의 요청을 하나 처리하는데 스레드는 CPU 를 1% 정도 사용하고 대부분 데이터베이스 서버에 어떤 결과를 조회하면서 기다린다고 가정하자.
            이때는 스레드는 CPU 를 거의 사용하지 않고 대기한다. 바로 I/O-바운드 작업이 많다는 것이다.
            이 경우 CPU 코어가 4개 있다고해서 스레드 숫자도 CPU 코어에 맞추어 4개로 설정하면 안된다!
            그러면 동시에 4명의 사용자 요청만 처리할 수 있다.
            이때 CPU 는 단순하게 계산해서 4% 정도만 사용할 것이다.
            결국 사용자는 동시에 4명밖에 못받지만 CPU 는 4%만 사용하며 CPU 가 놀고 있는 사태가 벌어질 수 있다.
            사용자의 요청 하나를 처리하는데 CPU 를 1%만 사용한다면 단순하게 생각해도 100개의 스레드를 만들 수 있다.
            이렇게 하면 동시에 100명의 사용자 요청을 받을 수 있다.
            물론 실무에서는 성능 테스트를 통해서 최적의 스레드 숫자를 찾는 것이 이상적이다.

            결국 스레드 숫자만 늘리면 되는데 이런 부분을 잘 이해하지 못해서 서버 장비에 문제가 있다고 생각하고 2배 더 좋은 장비로 구매하는 사태가 발생하기도 한다!
            이렇게 되면 CPU 는 4%의 절반인 2%만 사용하고 사용자는 여전히 동시에 4명 밖에 받지 못하는 사태가 벌어진다.
            정리하면 스레드의 숫자는 CPU-바운드 작업이 많은가 아니면 I/O-바운드 작업이 많은가에 따라 다르게 설정해야 한다.

            CPU-바운드 작업: CPU 코어 수 + 1개
                CPU 를 거의 100% 사용하는 작업이므로 스레드를 CPU 숫자에 최적화
            I/O-바운드 작업: CPU 코어 수 보다 많은 스레드를 생성, CPU 를 최대한 사용할 수 있는 숫자까지 스레드 생성
                CPU 를 많이 사용하지 않으므로 성능 테스트를 통해 CPU 를 최대한 활용하는 숫자까지 스레드 생성
                단, 너무 많은 스레드를 생성하면 컨텍스트 스위칭 비용도 함께 증가 - 적절한 성능 테스트 필요
                참고로 웹 애플리케이션 서버라도 상황에 따라 CPU 바운드 작업이 많을 수 있다. 이 경우 CPU-바운드 작업에 최적화된 CPU 숫자를 고려하면 된다.
    */
}
