package thread.bounded;

import java.util.ArrayDeque;
import java.util.Queue;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class BoundedQueueV2 implements BoundedQueue {
    private final Queue<String> queue = new ArrayDeque<>();
    private final int max;

    public BoundedQueueV2(int max) {
        this.max = max;
    }

    /*
    생산자 먼저
        생산자 스레드 p1, p2는 작업을 정상적으로 성공한다.
        생산자 스레드인 p3는 임계 영역에 들어가기 위해 먼저 락을 획득한다.
        큐에 data3 을 저장하려고 시도한다. 그런데 큐가 가득 차있다.
        p3는 sleep(1000) 을 사용해서 잠시 대기한다. 이때 RUNNABLE -> TIMED_WAITING 상태가 된다.
        반복문을 사용해서 1초마다 큐에 빈 자리가 있는지 반복해서 확인한다.
        이때 c1이 임계 영역에 들어가기 위해 락을 획득하려 한다.
        그런데 락이 없다. 왜냐하면 p3 가 락을 가지고 임계 영역에 이미 들어가 있기 때문이다.
        p3가 락을 반납하기 전까지는 c1 은 절대로 임계 영역에 들어갈 수 없다.
        p3는 락을 반납하지 않고 c1 은 큐의 데이터를 가져갈 수 없다.
        지금 상태면 p3는 절대로 락을 반납할 수 없다. 왜냐하면 락을 반납하려면 c1이 먼저 큐의 데이터를 소비해야 한다.
        그래야 p3가 큐에 data3 을 저장하고 임계 영역을 빠져나가며 락을 반납할 수 있다.
        그런데 p3가 락을 가지고 임계 영역 안에 있기 때문에 임계 영역 밖의 c1은 락을 획득할 수 없으므로 큐에 접근하지 못하고 무한 대기한다.
        결과적으로 producer3이 종료되지 않고 계속 수행되고 consumer1, consumer2, consumer3 은 BLOCKED 상태가 된다.

    소비자 먼저
        소비자 스레드인 c1은 임계영역에 들어가기 위해 락을 획득한다.
        c1은 큐의 데이터를 획득하려 하지만 데이터가 없다.
        c1은 sleep(1000) 을 사용해서 잠시 대기한다. 이때 RUNNABLE -> TIMED_WAITING 상태가 된다.
        반복문을 사용해서 1초마다 큐에 데이터가 있는지 반복해서 확인한다.
        이때 c2가 임계 영역에 들어가기 위해 락을 획득하려 한다.
        그런데 락이 없다. 왜냐하면 c1이 락을 가지고 임계 영역에 들어가 있기 때문이다.
        c1이 락을 반납하기 전까지는 c2는 절대로 임계 영역은 들어갈 수 없다.
        결과적으로 소비자 먼저 실행의 경우 consumer1이 종료되지 않고 계속 수행된다. 그리고 나머지 모든 스레드가 BLOCKED 상태가 된다.

    문제
        버퍼가 비었을 때 소비하거나 버퍼가 가득 찾을 때 생산하는 문제를 해결하기 위해 단순히 스레드가 잠깐 기다리면 될 것이라 생각했는데 문제가 더 심각해졌다.
        생각해보면 결국 임계 영역 안에서 락을 가지고 대기하는 것이 문제이다.
        이것은 마치 열쇠를 가진 사람이 안에서 문을 잠궈버린 것과 같다. 그래서 다른 스레드가 임계 영역안에 접근조차 할 수 없는 것이다.

        여기서 잘 생각해보면 락을 가지고 임계 영역안에 있는 스레드가 sleep() 을 호출해서 잠시 대기할 때는 아무일도 하지 않는다.
        그렇다면 이렇게 아무일도 하지 않고 대기하는 동안 잠시 다른 스레드에게 락을 양보하면 어떨까?
        그러면 다른 스레드가 버퍼에 값을 채우거나 버퍼의 값을 가져갈 수 있을 것이다.
        그러면 락을 가진 스레드도 버퍼에서 값을 획득하거나 값을 채우고 락을 반납할 수 있을 것이다.

        예를 들어 락을 가진 소비자 스레드가 임계 영역 안에서 버퍼의 값을 획득하기를 기다린다고 가정하자.
        버퍼에 값이 없으면 값이 채워질 때 까지 소비자 스레드는 아무일도 하지 않고 대기해야 한다.
        어차피 아무일도 하지 않으므로 이때 잠시 락을 다른 스레드에게 빌려주는 것이다.
        락을 획득한 생산자 스레드는 이때 버퍼에 값을 채우고 락을 반납한다.
        버퍼에 값이 차면 대기하던 소비자 스레드가 다시 락을 획득한 다음에 버퍼의 값을 가져가고 락을 반납하는 것이다.

        자바의 Object.wait(), Object.notify() 를 사용하면 락을 가지고 대기하는 스레드가 대기하는 동안 다른 스레드에게 락을 양보할 수 있다.
    */
    @Override
    public synchronized void put(String data) {
        /*
        데이터를 버리지 않는 대안
            data3 을 버리지 않는 대안은 큐가 가득 찾을 때 큐에 빈 공간이 생길 때 까지 생산자 스레드가 기다리면 된다.
            언젠가는 소비자 스레드가 실행되어서 큐의 데이터를 가져갈 것이고 그러면 큐에 데이터를 넣을 수 있는 공간이 생기게 된다.
            여기서는 생산자 스레드가 반복문을 사용해서 큐에 빈 공간이 생기는지 주기적으로 체크한다.
            만약 빈 공간이 없다면 sleep() 을 사용해서 잠시 대기하고 깨어난 다음에 다시 반복문에서 큐의 빈 공간을 체크하는 식으로 구현했다.
        */
        while(queue.size() == max) {
            log("[put] 큐가 가득 참, 생산자 대기");
            sleep(1000);
        }
        queue.offer(data);
    }

    @Override
    public synchronized String take() {
        /*
        데이터를 받지 못하는 대안
            소비자 입장에서 큐에 데이터가 없다면 기다리는 것도 대안이다.
            큐에 데이터가 없을 때 데이터가 추가될 때 까지 소비자 스레드가 기다리는 것이다.
            언젠가는 생산자 스레드가 실행되어서 큐의 데이터를 추가할 것이고 큐에 데이터가 생기게 된다.
            물론 생산자 스레드가 계속해서 데이터를 생산한다는 가정이 필요하다.
            여기서는 소비자 스레드가 반복문을 사용해서 큐에 데이터가 있는지 주기적으로 체크한다.
            만약 데이터가 없다면 sleep() 을 사용해서 잠시 대기하고 깨어난 다음에 다시 반복문에서 큐에 데이터가 있는지 체크하는 식으로 구현했다.
        */
        while(queue.isEmpty()) {
            log("[take] 큐에 데이터가 없음, 소비자 대기");
            sleep(1000);
        }
        return queue.poll();
    }

    @Override
    public String toString() {
        return queue.toString();
    }
}
