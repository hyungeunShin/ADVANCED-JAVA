package thread.bounded;

import java.util.ArrayDeque;
import java.util.Queue;

import static util.MyLogger.log;

public class BoundedQueueV3 implements BoundedQueue {
    private final Queue<String> queue = new ArrayDeque<>();
    private final int max;

    public BoundedQueueV3(int max) {
        this.max = max;
    }

    /*
    Object.wait()
        - 현재 스레드가 가진 락을 반납하고 대기(WAITING)한다.
        - 현재 스레드를 대기(WAITING) 상태로 전환한다.
          이 메서드는 현재 스레드가 synchronized 블록이나 메서드에서 락을 소유하고 있을 때만 호출할 수 있다.
          호출한 스레드는 락을 반납하고 다른 스레드가 해당 락을 획득할 수 있도록 한다.
          이렇게 대기 상태로 전환된 스레드는 다른 스레드가 notify() 또는 notifyAll() 을 호출할 때까지 대기 상태를 유지한다.

    Object.notify()
        - 대기 중인 스레드 중 하나를 깨운다.
        - 이 메서드는 synchronized 블록이나 메서드에서 호출되어야 한다.
          깨운 스레드는 락을 다시 획득할 기회를 얻게 된다.
          만약 대기 중인 스레드가 여러 개라면 그 중 하나만이 깨워지게 된다.

    Object.notifyAll()
        - 대기 중인 모든 스레드를 깨운다.
        - 이 메서드 역시 synchronized 블록이나 메서드에서 호출되어야 하며 모든 대기 중인 스레드가 락을 획득할 수 있는 기회를 얻게 된다.
          이 방법은 모든 스레드를 깨워야 할 필요가 있는 경우에 유용하다.

    스레드 대기 집합(wait set)
        - synchronized 임계 영역 안에서 Object.wait() 를 호출하면 스레드는 대기(WAITING) 상태에 들어간다.
          이렇게 대기 상태에 들어간 스레드를 관리하는 것을 대기 집합(wait set)이라 한다.
          참고로 모든 객체는 각자의 대기 집합을 가지고 있다.
        - 모든 객체는 락(모니터 락)과 대기 집합을 가지고 있다. 둘은 한 쌍으로 사용된다.
          따라서 락을 획득한 객체의 대기 집합을 사용해야 한다.

    생산자 먼저
        p1, p2가 순차적으로 데이터 생산을 완료한다.
        이때 각각의 스레드는 notify() 를 호출하여 스레드 대기 집합에서 대기하는 스레드 중 하나를 깨우지만 현재 대기 집합에 스레드가 없으므로 아무일도 발생하지 않는다.
        p3 가 데이터를 생산하려고 하는데 큐가 가득 찼다. wait() 를 호출한다.
        wait() 를 호출하면 락을 반납하고 스레드의 상태가 RUNNABLE -> WAITING 로 변경된다. 또한 스레드 대기 집합에서 관리된다.
        c1이 data1을 획득하면서 큐에 데이터를 보관할 빈 자리가 생겼다.
        c1은 notify() 를 호출해서 스레드 대기 집합에 이 사실을 알린다.
        스레드 대기 집합은 notify() 신호를 받으면 대기 집합에 있는 스레드 중 하나를 깨운다.
        그런데 대기 집합에 있는 스레드가 깨어난다고 바로 작동하는 것은 아니다. 깨어난 스레드는 여전히 임계 영역 안에 있다.
        임계 영역에 있는 코드를 실행하려면 먼저 락이 필요하다.
        p3 는 대기 집합에서는 나가지만 여전히 임계 영역에 있으므로 락을 획득하기 위해 BLOCKED 상태로 대기한다.
        당연한 이야기지만 임계 영역 안에서 2개의 스레드가 실행되면 큰 문제가 발생한다.
        참고로 이때 임계 영역의 코드를 처음으로 돌아가서 실행하는 것은 아니다.
        대기 집합에 들어오게 된 wait() 를 호출한 부분 부터 실행된다. 락을 획득하면 wait() 이후의 코드를 실행한다.
        c1은 데이터 소비를 완료하고 락을 반납하고 임계 영역을 나간다.
        p3 가 락을 획득하고 스레드 상태가 BLOCKED -> RUNNABLE 로 변경되며 wait() 코드에서 대기했기 때문에 이후의 코드를 실행한다.
        p3는 data3을 저장하고 notify() 를 호출하여 스레드 대기 집합에서 대기하는 스레드 중 하나를 깨우지만 현재 대기 집합에 스레드가 없으므로 아무일도 발생하지 않는다.
        c2, c3가 실행된다.

    소비자 먼저
        큐에 데이터가 없기 때문에 c1, c2, c3 모두 스레드 대기 집합에서 대기한다.
        p1 은 락을 획득하고 큐에 데이터를 생산한다. 큐에 데이터가 있기 때문에 소비자를 하나 깨울 수 있다.
        notify() 를 통해 스레드 대기 집합에 이 사실을 알려준다.
        notify() 를 받은 스레드 대기 집합은 스레드 중에 하나를 깨운다.

        여기서 c1, c2, c3 중에 어떤 스레드가 깨어날까? 예측할 수 없다.
        어떤 스레드가 깨워질지는 JVM 스펙에 명시되어 있지 않다. 따라서 JVM 버전 환경등에 따라서 달라진다.
        여기에서는 c1, c2, c3가 순차적으로 깨어난다고 가정한다.

        그런데 대기 집합에 있는 스레드가 깨어난다고 바로 작동하는 것은 아니다. 깨어난 스레드는 여전히 임계 영역 안에 있다.
        임계 영역에 있는 코드를 실행하려면 먼저 락이 필요하다.
        대기 집합에서는 나가지만 여전히 임계 영역에 있으므로 락을 획득하기 위해 BLOCKED 상태로 대기한다.
        p1 생산이 완료되어 c1은 락을 획득하고 임계 영역 안에서 실행되며 데이터를 획득한다.
        c1 이 notify() 로 스레드 대기 집합에 알렸지만 스레드 대기 집합에는 소비자 스레드만 있다.
        따라서 소비자 스레드인 c2가 대기 상태에서 깨어난다.
        하지만 큐에 데이터가 없기 때문에 c2는 결국 wait() 를 호출해서 대기 상태로 변하며 다시 대기 집합에 들어간다.
        p2가 락을 획득하고 데이터를 저장하며 이 과정을 반복한다.

        이처럼 소비자인 c1이 같은 소비자인 c2를 깨우는 것은 상당히 비효율적이다.
        c1 입장에서 c2를 깨우게 되면 아무 일도 하지 않고 그냥 다시 스레드 대기 집합에 들어갈 수 있다.
        결과적으로 CPU 만 사용하고 아무 일도 하지 않은 상태로 다시 대기 상태가 되어버린다.
        그렇다고 c1이 스레드 대기 집합에 있는 어떤 스레드를 깨울지 선택할 수는 없다.
        notify() 는 스레드 대기 집합에 있는 스레드 중 임의의 하나를 깨울 뿐이다.
        이것이 비효율적이라는 것이지 문제가 되는 것은 아니다.

    wait, notify 한계
        큐에 데이터가 없는 상황에 소비자가 같은 소비자를 깨우는 비효율이 발생할 수 있다.
        또는 큐에 데이터가 가득 차있는데 생산자가 같은 생산자를 깨우는 비효율도 발생할 수 있다.

        스레드 기아(thread starvation)
            소비자가 5개, 생산자가 1개만 있고 모두 스레드 대기 집합에 대기중이라고 가정한다.
            notify() 가 어떤 스레드를 깨울지는 알 수 없다. 최악의 경우 c1 ~ c5 스레드가 반복해서 깨어날 수 있다.
            p1 은 실행 순서를 얻지 못하다가 아주 나중에 깨어날 수도 있다.
            이렇게 대기 상태의 스레드가 실행 순서를 계속 얻지 못해서 실행되지 않는 상황을 스레드 기아(starvation) 상태라 한다.
            물론 p1 이 가장 먼저 실행될 수도 있다.
            이런 문제를 해결하는 방법 중에 notify() 대신에 notifyAll() 을 사용하는 방법이 있다.
            notifyAll() 을 사용하면 스레드 대기 집합에 있는 모든 스레드를 한번에 다 깨울 수 있다.
            대기 집합에 있는 모든 스레드가 깨어난다.
            모든 스레드는 다 임계 영역 안에 있다. 따라서 락을 먼저 획득해야 한다.
            만약 c1 이 먼저 락을 먼저 획득한다면 큐에 데이터가 없으므로 다시 스레드 대기 집합에 들어간다.
            c2 ~ c5 모두 마찬가지이다.
            따라서 p1 이 가장 늦게 락 획득을 시도해도 c1 ~ c5 는 모두 스레드 대기 집합에 들어갔으므로 결과적으로 p1 만 남게 되고 락을 획득한다.
            하지만 notifyAll() 을 사용해서 스레드 기아 문제는 막을 수 있지만 비효율을 막지는 못한다.
    */
    @Override
    public synchronized void put(String data) {
        /*
        synchronized 를 통해 임계 영역을 설정한다. 생산자 스레드는 락 획득을 시도한다.
        락을 획득한 생산자 스레드는 반복문을 사용해서 큐에 빈 공간이 생기는지 주기적으로 체크한다.
        만약 빈 공간이 없다면 Object.wait() 을 사용해서 대기한다. 참고로 대기할 때 락을 반납하고 대기한다.
        그리고 대기 상태에서 깨어나면 다시 반복문에서 큐의 빈 공간을 체크한다.
        wait() 를 호출해서 대기하는 경우 RUNNABLE -> WAITING 상태가 된다.
        생산자가 데이터를 큐에 저장하고 나면 notify() 를 통해 저장된 데이터가 있다고 대기하는 스레드에 알려주어야 한다.

        예를 들어서 큐에 데이터가 없어서 대기하는 소비자 스레드가 있다고 가정하자.
        이때 notify() 를 호출하면 소비자 스레드는 깨어나서 저장된 데이터를 획득할 수 있다.
        */
        while(queue.size() == max) {
            log("[put] 큐가 가득 참, 생산자 대기");

            try {
                wait();
                log("[put] 생산자 깨어남");
            } catch(InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        queue.offer(data);
        log("[put] 생산자 데이터 저장, notify() 호출");
        //notify();
        notifyAll();
    }

    @Override
    public synchronized String take() {
        /*
        synchronized 를 통해 임계 영역을 설정한다. 소비자 스레드는 락 획득을 시도한다.
        락을 획득한 소비자 스레드는 반복문을 사용해서 큐에 데이터가 있는지 주기적으로 체크한다.
        만약 데이터가 없다면 Object.wait() 을 사용해서 대기한다. 참고로 대기할 때 락을 반납하고 대기한다.
        그리고 대기 상태에서 깨어나면 다시 반복문에서 큐에 데이터가 있는지 체크한다.
        대기하는 경우 RUNNABLE -> WAITING 상태가 된다.
        소비자가 데이터를 획득하고 나면 notify() 를 통해 큐에 저장할 여유 공간이 생겼다고 대기하는 스레드에게 알려주어야 한다.

        예를 들어서 큐에 데이터가 가득 차서 대기하는 생산자 스레드가 있다고 가정하자.
        이때 notify() 를 호출하면 생산자 스레드는 깨어나서 데이터를 큐에 저장할 수 있다.
        */
        while(queue.isEmpty()) {
            log("[take] 큐에 데이터가 없음, 소비자 대기");

            try {
                wait();
                log("[take] 소비자 깨어남");
            } catch(InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        String data = queue.poll();
        log("[take] 소비자 데이터 획득, notify() 호출");
        //notify();
        notifyAll();
        return data;
    }

    @Override
    public String toString() {
        return queue.toString();
    }
}
