package thread.cas.spinlock;

import java.util.concurrent.atomic.AtomicBoolean;

import static util.MyLogger.log;

public class SpinLock {
    /*
    원자적인 연산은 스레드 입장에서 쪼갤 수 없는 하나의 연산이다. 따라서 여러 스레드가 동시에 실행해도 안전하다.
    이렇게 CAS 를 사용해서 원자적인 연산을 만든 덕분에 무거운 동기화 작업 없이 아주 가벼운 락을 만들 수 있었다.
    동기화 락을 사용하는 경우 스레드가 락을 획득하지 못하면 BLOCKED, WAITING 등으로 상태가 변한다.
    그리고 또 대기 상태의 스레드를 깨워야 하는 무겁고 복잡한 과정이 추가로 들어간다.
    따라서 성능이 상대적으로 느릴 수 있다.
    반면에 CAS 를 활용한 락 방식은 사실 락이 없다.
    단순히 while 문을 반복할 뿐이다. 따라서 대기하는 스레드도 RUNNABLE 상태를 유지하면서 가볍고 빠르게 작동할 수 있다.

    CAS 단점
        SpinLockMain 코드에 있는 sleep(1) 주석을 풀고 실행해보자.

        이 방식은 락을 기다리는 스레드가 BLOCKED, WAITING 상태로 빠지지는 않지만 RUNNABLE 상태로 락을 획득할때 까지 while 문을 반복하는 문제가 있다.
        따라서 락을 기다리는 스레드가 CPU 를 계속 사용하면서 대기하는 것이다.
        BLOCKED, WAITING 상태의 스레드는 CPU 를 거의 사용하지 않지만 RUNNABLE 상태로 while 문을 반복 실행하는 방식은 CPU 자원을 계속해서 사용하는 것이다.

        동기화 락을 사용하면 RUNNABLE 상태의 스레드가 BLOCKED, WAITING 상태에서 다시 RUNNABLE 상태로 이동한다.
        이 사이에 CPU 자원을 거의 사용하지 않을 수 있다.
        그래서 동기화 락을 사용하는 방식보다 스레드를 RUNNABLE 로 살려둔 상태에서 계속 락 획득을 반복 체크하는 것이 더 효율적인 경우에 이런 방식을 사용해야 한다.
        이 방식은 스레드의 상태가 변경되지 않기 때문에 매우 빠르게 락을 획득하고 또 바로 실행할 수 있는 장점이 있다.

        그럼 어떤 경우에 이런 방식이 효율적일까?
        안전한 임계 영역이 필요하지만 연산이 길지 않고 매우 짧게 끝날 때 사용해야 한다.
        예를 들어 숫자 값의 증가, 자료 구조의 데이터 추가와 같이 CPU 사이클이 금방 끝나는 연산에 사용하면 효과적이다.
        반면에 데이터베이스의 결과를 대기한다거나 다른 서버의 요청을 기다린다거나 하는 것 처럼 오래 기다리는 작업에 사용하면 CPU 를 계속 사용하며 기다리는 최악의 결과가 나올 수도 있다.

    스핀 락
        스레드가 락이 해제되기를 기다리면서 반복문을 통해 계속해서 확인하는 모습이 마치 제자리에서 회전(spin)하는 것처럼 보인다.
        그래서 이런 방식을 "스핀 락"이라고도 부른다.
        그리고 이런 방식에서 스레드가 락을 획득 할 때 까지 대기하는 것을 스핀 대기(spin-wait) 또는 CPU 자원을 계속 사용하면서 바쁘게 대기한다고 해서 바쁜 대기(busy-wait)라 한다.
        이런 스핀 락 방식은 아주 짧은 CPU 연산을 수행할 때 사용해야 효율적이다.
        잘못 사용하면 오히려 CPU 자원을 더 많이 사용할 수 있다.
        정리하면 "스핀 락"이라는 용어는 락을 획득하기 위해 자원을 소모하면서 반복적으로 확인(스핀)하는 락 메커니즘을 의미한다.
        그리고 이런 스핀 락은 CAS 를 사용해서 구현할 수 있다.
    */

    private final AtomicBoolean lock = new AtomicBoolean(false);

    public void lock() {
        log("락 획득 시도");
        while(!lock.compareAndSet(false, true)) {
            log("락 획득 실패 - 스핀 대기");
        }
        log("락 획득 완료");
    }

    public void unlock() {
        lock.set(false);
        log("락 반납 완료");
    }
}
