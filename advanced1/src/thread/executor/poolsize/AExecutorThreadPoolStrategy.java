package thread.executor.poolsize;

//Executor 스레드 풀 관리 전략
public class AExecutorThreadPoolStrategy {
    /*
    Executor 스레드 풀 관리
        1. 작업을 요청하면 core 사이즈 만큼 스레드를 만든다.
        2. core 사이즈를 초과하면 큐에 작업을 넣는다.
        3. 큐를 초과하면 max 사이즈 만큼 스레드를 만든다. 임시로 사용되는 초과 스레드가 생성된다.
        4. max 사이즈를 초과하면 요청을 거절한다. 예외가 발생한다.

    ThreadPoolExecutor 를 사용하면 스레드 풀에 사용되는 숫자와 블로킹 큐등 다양한 속성을 조절할 수 있다.
        - corePoolSize : 스레드 풀에서 관리되는 기본 스레드의 수
        - maximumPoolSize : 스레드 풀에서 관리되는 최대 스레드 수
        - keepAliveTime, TimeUnit unit : 기본 스레드 수를 초과해서 만들어진 스레드가 생존할 수 있는 대기 시간, 이 시간 동안 처리할 작업이 없다면 초과 스레드는 제거된다.
        - BlockingQueue workQueue : 작업을 보관할 블로킹 큐

    이런 속성들을 조절하면 자신에게 맞는 스레드 풀 전략을 사용할 수 있다.

    자바는 Executors 클래스를 통해 3가지 기본 전력을 제공한다.
        - newSingleThreadPool(): 단일 스레드 풀 전략
            - 스레드 풀에 기본 스레드 1개만 사용한다.
            - 큐 사이즈에 제한이 없다. (LinkedBlockingQueue)
            - 주로 간단히 사용하거나 테스트 용도로 사용한다.
            - new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())

        - newFixedThreadPool(nThreads): 고정 스레드 풀 전략
            - 스레드 풀에 nThreads 만큼의 기본 스레드를 생성한다. 초과 스레드는 생성하지 않는다.
            - 큐 사이즈에 제한이 없다. (LinkedBlockingQueue)
            - 스레드 수가 고정되어 있기 때문에 CPU, 메모리 리소스가 어느정도 예측 가능한 안정적인 방식이다.
            - new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())

        - newCachedThreadPool(): 캐시 스레드 풀 전략
            - 기본 스레드를 사용하지 않고 60초 생존 주기를 가진 초과 스레드만 사용한다.
            - 초과 스레드의 수는 제한이 없다.
            - 큐에 작업을 저장하지 않는다. (SynchronousQueue)
                - 대신에 생산자의 요청을 스레드 풀의 소비자 스레드가 직접 받아서 바로 처리한다.
            - 모든 요청이 대기하지 않고 스레드가 바로바로 처리한다. 따라서 빠른 처리가 가능하다.
            - new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());

            ※ 참고
                SynchronousQueue 는 아주 특별한 블로킹 큐이다.
                    - BlockingQueue 인터페이스의 구현체 중 하나이다.
                    - 이 큐는 내부에 저장 공간이 없다. 대신에 생산자의 작업을 소비자 스레드에게 직접 전달한다.
                    - 쉽게 이야기해서 저장 공간의 크기가 0이고 생산자 스레드가 큐가 작업을 전달하면 소비자 스레드가 큐에서 작업을 꺼낼 때까지 대기한다.
                    - 소비자 작업을 요청하면 기다리던 생산자가 소비자에게 직접 작업을 전달하고 반환된다. 그 반대의 경우도 같다.
                    - 이름 그대로 생산자와 소비자를 동기화하는 큐이다.
                    - 쉽게 이야기해서 중간에 버퍼를 두지 않는 스레드간 직거래라고 생각하면 된다.

    실무 전략 선택
        고정 스레드 풀 전략: 트래픽이 일정하고 시스템 안전성이 가장 중요
        캐시 스레드 풀 전략: 일반적인 성장하는 서비스
        사용자 정의 풀 전략: 다양한 상황에 대응

        많은 개발자가 미래에 발생하지 않을 일 때문에 코드를 최적화하는 경우가 많다.
        예를 들어서 초기 서비스이고 아직 사용자가 많을지 예측이 되지 않는 상황인데 코드 최적화에 너무 많은 시간을 사용할 수 있다.
        이것은 사용자는 얼마 없는데 매우 비싼 서버를 구매하는 것과 같다. 물론 이 이야기가 극단적으로 최적화를 하지 말자는 말이 아니다.

        예를 들어서 A와 관련된 기능을 매우 많이 최적화 했는데 사용자가 없어서 결국 버리게 되는 경우도 있다.
        반면에 별로 신경쓰지 않은 B와 관련된 기능에 사용자가 많이 늘어날 수도 있다.
        중요한 것은 예측 불가능한 너무 먼 미래 보다는 현재 상황에 맞는 최적화가 필요하다는 점이다.
        시스템의 상황을 잘 모니터링 하고 있다가 최적화가 필요한 부분들이 발생하면 그때 필요한 부분들을 개선하는 것이다.

        우리가 만든 서비스가 잘 되어서 많은 요청이 들어오면 좋겠지만 대부분의 서비스는 트래픽이 어느정도 예측 가능하다.
        그리고 성장하는 서비스라도 어느정도 성장이 예측 가능하다.
        그래서 일반적인 상황이라면 고정 스레드 풀 전략이나 캐시 스레드 풀 전략을 사용하면 충분하다.
        한번에 처리할 수 있는 수를 제안하고 안정적으로 처리하고 싶다면 고정 풀 전략을 선택하고 사용자의 요청을 빠르게 대응하고 싶다면 캐시 스레드 풀 전략을 사용하면 된다.
        물론 자원만 충분하다면 고정 풀 전략을 선택하면서 풀의 수를 많이 늘려서 사용자의 요청도 빠르게 대응하면서 안정적인 서비스 운영도 가능하다.
    */
}
