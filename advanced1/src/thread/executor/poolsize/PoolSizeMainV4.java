package thread.executor.poolsize;

import thread.executor.RunnableTask;

import java.util.concurrent.*;

import static thread.executor.util.ExecutorUtils.printState;
import static util.MyLogger.log;

//사용자 정의 풀 전략
public class PoolSizeMainV4 {
    /*
    상황1 - 점진적인 사용자 확대
        개발한 서비스가 잘 되어서 사용자가 점점 늘어난다.
    상황2 - 갑작스런 요청 증가
        마케팅 팀의 이벤트가 대성공 하면서 갑자기 사용자가 폭증했다.

    다음과 같이 세분화된 전략을 사용하면 상황1, 상황2를 모두 어느정도 대응할 수 있다.
        - 일반: 일반적인 상황에는 CPU, 메모리 자원을 예측할 수 있도록 고정 크기의 스레드로 서비스를 안정적으로 운영한다.
        - 긴급: 사용자의 요청이 갑자기 증가하면 긴급하게 스레드를 추가로 투입해서 작업을 빠르게 처리한다.
        - 거절: 사용자의 요청이 폭증해서 긴급 대응도 어렵다면 사용자의 요청을 거절한다.

    이 방법은 평소에는 안정적으로 운영하다가 사용자의 요청이 갑자기 증가하면 긴급하게 스레드를 더 투입해서 급한 불을 끄는 방법이다.
    물론 긴급 상황에는 CPU, 메모리 자원을 더 사용하기 때문에 적정 수준을 찾아야 한다.
    일반적으로는 여기까지 대응이 되겠지만 시스템이 감당할 수 없을 정도로 사용자의 요청이 폭증하면 처리 가능한 수준의 사용자 요청만 처리하고 나머지 요청은 거절해야 한다.

    이 전략은 다음과 같이 작동한다.
    하나의 작업을 처리하는데 약 1초가 걸린다고 가정하겠다.
        - 일반: 1000개 이하의 작업이 큐에 담겨있다. 100개의 기본 스레드가 처리한다.
            - 1000개 이하의 작업이 큐에 담겨있다. 100개의 기본 스레드가 처리한다.
            - 최대 1000개의 작업이 큐에 대기하고 100개의 작업이 실행중일 수 있다. 따라서 1100개 까지는 기본 스레드로 처리할 수 있다.
            - 작업을 모두 처리하는데 11초가 걸린다. 1100 / 100 = 11초

        - 긴급: 큐에 담긴 작업이 1000개를 초과한다. 100개의 기본 스레드 + 100개의 초과 스레드가 처리한다.
            - 큐에 담긴 작업이 1000개를 초과한다. 100개의 기본 스레드 + 100개의 초과 스레드가 처리한다.
            - 최대 1000개의 작업이 대기하고 200개의 작업이 실행중일 수 있다.
            - 작업을 모두 처리하는데 6초가 걸린다. 1200 / 200 = 6초
            - 긴급 투입한 스레드 덕분에 풀의 스레드 수가 2배가 된다. 따라서 작업을 2배 빠르게 처리한다.
            - 물론 CPU, 메모리 사용을 더 하기 때문에 이런 부분은 감안해서 긴급 상황에 투입할 최대 스레드를 정해야 한다.

        - 거절: 초과 스레드를 투입했지만 큐에 담긴 작업 1000개를 초과하고 또 초과 스레드도 넘어간 상황이다. 이 경우 예외를 발생시킨다.
            - 긴급 투입한 스레드로도 작업이 빠르게 소모되지 않는다는 것은 시스템이 감당하기 어려운 많은 요청이 들어오고 있다는 의미이다.
            - 여기서는 큐에 대기하는 작업 1000개 + 스레드가 처리 중인 작업 200개 총 1200개의 작업을 초과하면 예외가 발생한다.
            - 따라서 1201번에서 예외가 발생한다.
            - 이런 경우 요청을 거절한다. 고객 서비스라면 시스템에 사용자가 너무 많으니 나중에 다시 시도해달라고 해야 한다.
            - 나머지 1200개의 작업들은 긴급 상황과 같이 정상 처리된다.

    실무에서 자주 나오는 실수
        new ThreadPoolExecutor(100, 200, 60, TimeUnit.SECONDS, new LinkedBlockingQueue());  //기본 스레드 100개, 최대 스레드 200개, 큐 사이즈: 무한대
        이렇게 설정하면 절대로 최대 사이즈 만큼 늘어나지 않는다.
        왜냐하면 큐가 가득차야 긴급 상황으로 인지 되는데 LinkedBlockingQueue 를 기본 생성자를 통해 무한대의 사이즈로 사용하게 되면 큐가 가득찰 수 가 없다.
        결국 기본 스레드 100개만으로 무한대의 작업을 처리해야 하는 문제가 발생한다.
    */

    //static final int TASK_SIZE = 1100;    //1. 일반
    static final int TASK_SIZE = 1200;    // 2. 긴급
    //static final int TASK_SIZE = 1201;    // 3. 거절

    public static void main(String[] args) {
        /*
        100개의 기본 스레드를 사용한다.
        추가로 긴급 대응 가능한 긴급 스레드 100개를 사용한다. 긴급 스레드는 60초의 생존 주기를 가진다.
        1000개의 작업이 큐에 대기할 수 있다.
        */
        ExecutorService es = new ThreadPoolExecutor(100, 200, 60, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1000));
        printState(es);

        long start = System.currentTimeMillis();

        for(int i = 1; i <= TASK_SIZE; i++) {
            String task = "task" + i;
            try {
                es.execute(new RunnableTask(task));
                printState(es, task);
            } catch(RejectedExecutionException e) {
                log(task + " -> " + e);
            }
        }

        es.close();
        long end = System.currentTimeMillis();
        log("time : " + (end - start));
    }
}
