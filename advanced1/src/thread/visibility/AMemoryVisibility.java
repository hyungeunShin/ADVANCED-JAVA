package thread.visibility;

public class AMemoryVisibility {
    /*
    [VolatileFlagMain.class]

    boolean flag = true;
        실제 실행 결과를 보면 task 종료 가 출력되지 않는다.
        그리고 자바 프로그램도 멈추지 않고 계속 실행된다.
        정확히는 work 스레드가 while 문에서 빠져나오지 못하고 있는 것이다.
        이때 work 스레드가 실행하는 while(flag) 조건은 false 가 된다.
        따라서 work 스레드는 while 문을 빠져나오고 task 종료를 출력해야 한다.
        도대체 어떻게 된 일일까?

        실제 메모리의 접근 방식
            CPU 는 처리 성능을 개선하기 위해 중간에 캐시 메모리라는 것을 사용한다.
                - 메인 메모리는 CPU 입장에서 보면 거리도 멀고 속도도 상대적으로 느리다.
                  대신에 상대적으로 가격이 저렴해서 큰 용량을 쉽게 구성할 수 있다.
                - CPU 연산은 매우 빠르기 때문에 CPU 연산의 빠른 성능을 따라가려면 CPU 가까이에 매우 빠른 메모리가 필요한데 이것이 바로 캐시 메모리이다.
                  캐시 메모리는 CPU 와 가까이 붙어있고 속도도 매우 빠른 메모리이다.
                  하지만 상대적으로 가격이 비싸기 때문에 큰 용량을 구성하기는 어렵다.
                - 현대의 CPU 대부분은 코어 단위로 캐시 메모리를 각각 보유하고 있다.
                    - 참고로 여러 코어가 공유하는 캐시 메모리도 있다.

            - main 스레드가 CPU 코어1을 사용하고 work 스레드가 CPU 코어2를 사용한다고 가정하자.
            - 각 스레드가 flag 의 값을 사용하면 CPU 는 이 값을 효율적으로 처리하기 위해 먼저 flag 를 캐시 메모리에 불러온다.
            - 그리고 이후에는 캐시 메모리에 있는 flag 를 사용하게 된다.
            - 자바 프로그램을 실행하고 main 스레드와 work 스레드는 모두 flag 의 값을 읽는다.
            - CPU 는 이 값을 효율적으로 처리하기 위해 먼저 캐시 메모리에 불러온다.
            - main 스레드와 work 스레드가 사용하는 flag 가 각각의 캐시 메모리에 보관된다.
            - 프로그램의 시작 시점에는 flag 를 변경하지 않기 때문에 모든 스레드에서 true 의 값을 읽는다.
            - work 스레드의 경우 while(flag[true]) 가 만족하기 때문에 while 문을 계속 반복해서 수행한다.

            여기서 핵심은 캐시 메모리의 flag 값만 변한다는 것이다. 메인 메모리에 이 값이 즉시 반영되지 않는다.
                - main 스레드가 flag 의 값을 변경해도 CPU 코어1이 사용하는 캐시 메모리의 flag 값만 false 로 변경된다.
                - work 스레드가 사용하는 CPU 코어2의 캐시 메모리의 flag 값은 여전히 true 이다.
                - work 스레드의 경우 while(flag[true]) 가 만족하기 때문에 while 문을 계속 반복해서 수행한다.

            캐시 메모리에 있는 flag 의 값이 언제 메인 메모리에 반영될까?
                이 부분에 대한 정답은 "알 수 없다"이다. CPU 설계 방식과 종류의 따라 다르다. 극단적으로 보면 평생 반영되지 않을 수도 있다.
                메인 메모리에 반영을 한다고 해도 문제는 여기서 끝이 아니다.
                메인 메모리에 반영된 flag 값을 work 스레드가 사용하는 캐시 메모리에 다시 불러와야 한다.

            메인 메모리에 변경된 flag 값이 언제 CPU 코어2의 캐시 메모리에 반영될까?
                이 부분에 대한 정답도 "알 수 없다"이다. CPU 설계 방식과 종류의 따라 다르다. 극단적으로 보면 평생 반영되지 않을 수도 있다.
                언젠가 CPU 코어2의 캐시 메모리에 flag 값을 불러오게 되면 work 스레드가 확인하는 flag 의 값이 false 가 되므로 while 문을 탈출하고 "task 종료" 를 출력한다.

            ※ 캐시 메모리를 메인 메모리에 반영하거나 메인 메모리의 변경 내역을 캐시 메모리에 다시 불러오는 것은 언제 발생할까?
                이 부분은 CPU 설계 방식과 실행 환경에 따라 다를 수 있다.
                즉시 반영될 수도 있고 몇 밀리초 후에 될 수도 있고 몇 초 후에 될 수도 있고 평생 반영되지 않을 수도 있다.
                주로 컨텍스트 스위칭이 될 때 캐시 메모리도 함께 갱신되는데 이 부분도 환경에 따라 달라질 수 있다.
                예를 들어 Thread.sleep() 이나 콘솔에 내용을 출력할 때 스레드가 잠시 쉬는데 이럴 때 컨텍스트 스위칭이 되면서 주로 갱신된다.
                하지만 이것이 갱신을 보장하는 것은 아니다.

    메모리 가시성(memory visibility)
        이처럼 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 메모리 가시성(memory visibility)이라 한다.
        이름 그대로 메모리에 변경한 값이 보이는가 보이지 않는가의 문제이다.
        그렇다면 한 스레드에서 변경한 값이 다른 스레드에서 즉시 보이게 하려면 어떻게 해야할까?

    volatile boolean flag = true;
        캐시 메모리를 사용하면 CPU 처리 성능을 개선할 수 있다.
        하지만 때로는 이런 성능 향상보다는 여러 스레드에서 같은 시점에 정확히 같은 데이터를 보는 것이 더 중요할 수 있다.
        해결방안은 아주 단순하다. 성능을 약간 포기하는 대신에 값을 읽을 때, 값을 쓸 때 모두 메인 메모리에 직접 접근하면 된다.
        자바에서는 volatile 이라는 키워드로 이런 기능을 제공한다.
    */
}
